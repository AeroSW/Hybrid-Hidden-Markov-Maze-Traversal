import random
class Action:
    def __init__(self, aKey, result, result_chances=1.0, create_counter_table=False):
        '''
        Preconditions:
            Required:
                aKey - comparable object
                    The key for this action, so it can be searched if needed.
                result - object or list
                    an object or a list storing possible results for performing this action
            Unrequired:
                result_chance - float or list
                    Default Value is 1 or 100%
                    Used to calculate the chance that an action was successful.
                    Stores the chances that a result can be reached.
                    **If result was a list, then this has to be a list of equal size.**
                create_counter_table - Boolean
                    Default value is False
                    Determines whether we need to count up the individual states reached by
                    performing this action.
        Postconditions:
            This function returns an Action object that can be used.
        Errors:
            ValueError - Raised if total num result_chances does not equal total num results
        '''
        # result dictionary is stored with State # as the key and the floating
        # percentile chance as the value for that key.
        self.action_key = aKey # Set the action key
        if(isinstance(result, list)):
            self.__results = result
            self.numResults = result.__len__()
        else:
            self.__results = list()
            self.__results.append(result)
            self.numResults = 1
            
        self.results_len = result.__len__()
        
        if(isinstance(result_chances, list)):
            if(result_chances.__len__() == self.numResults):
                self.__results_chances = result_chances
            else:
                raise ValueError
        else:
            if(numResults != 1):
                raise ValueError
            else:
                self.__results_chances = list()
                self.__results_chances.append(result_chances)
        
        self.countResults = create_counter_table
        
        if(create_counter_table == True):
            self.counter_list = dict()
            for i in self.__results:
                self.counter_list[i.getKey()] = 0
    
    def testAction(self):
        '''
        Preconditions:
            None
        Postconditions:
            Returns the result of performing an action based on a probability
            generated by randomly generating a number between 0 and 1 inclusive.
            It returns -1 though if the action had failed.
        '''
        rand_num = random.randint(1, 100000)
        rand_num = rand_num/100000
        prev_value = 0
        for i in range(self.results_len):
            curr_value = prev_value + self.__results_chances[i]
            if(prev_value < rand_num and rand_num < curr_value):
                if(self.countResults):
                    self.counter_list[self.__results[i].getKey()] = self.counter_list[self.__results[i].getKey()] + 1
                return self.__results[i]
            prev_value = curr_value
        return -1 # indicates failure
        
    def getKey(self):
        '''
        Preconditions:
            None
        Postconditions:
            Returns the search key for this action.
        '''
        return self.action_key
    
    def getCount(self):
        '''
        Preconditions:
            None
        Postconditions:
            returns the counting table for each state reached by performing this action.
        Errors:
            NumberError - if counting is not implemented for this action.
        '''
        if(self.countResults == True):
            return self.counter_list
        raise NumberError
    
    def getNumResults(self):
        '''
        Preconditions:
            None
        Postconditions:
            Returns the number of possible results that this action could reach.
        '''
        return self.results_len
    
    